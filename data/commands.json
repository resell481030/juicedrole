[null,{"name":"test","permissions":"NONE","restriction":"1","_id":"yKqek","actions":[{"channel":"0","varName":"","message":"test","storage":"0","varName2":"","name":"Send Message"}]},{"name":"rolemenu","permissions":"NONE","restriction":"1","_id":"DtBMG","actions":[{"code":"const Discord = require(\"discord.js\");\nconst fs = require('fs');\n\nlet rectarray = globalVars('reactionRoleInf');\n\nlet reactionArray = [];\nlet emojiArray = [];\nlet roleArray = [];\nvar embedSettings = [];\n\nconst _this = this;\n\nlet errorCatch = 5;\nlet emojiTimerRe = 0;\n\nlet localEmoji;\nlet localEmojiG;\nvar interval;\n\n\nlet embedTemplate = new Discord.RichEmbed({\n    color:  16199315,\n    author: {\n        name: client.user.username,\n        icon_url: client.user.avatarURL\n    },\n    title: \"Terminal Role Reaction coded by yaSS\",\n    description: \"Ceci est un test de pr√©visualisation.\",\n    timestamp: new Date(),\n})\n\n// Settings\nlet grabAllEmoji = true; // Default: false || Set true if you want the bot to use global emojis from all the servers its in. (May cause slowdowns in larger servers)\nlet roleLimit = 20; // Default: 10 || Sets the maximum number of roles attached to emojis.\nlet debug = false; // Default: false || Prints any errors that may have occured; will also print for await messages that ran out of time\n//\n\nif (grabAllEmoji) {\n    localEmoji = (client || this.getDBM().Bot.bot).emojis.array();\n    localEmojiG = \"Veuillez vous assurer que l'emoji que vous avez s√©lectionn√© se trouve sur l'un des serveurs sur lesquel se trouve le bot!\";\n} else {\n    localEmoji = msg.guild.emojis.array();\n    localEmojiG = \"Veuillez vous assurer que l'emoji que vous avez s√©lectionn√© se trouve sur ce serveur!\";\n}\n\nif (msg.member.hasPermission('MANAGE_ROLES')) {\n    embedTemplate[\"description\"] = `Bienvenue dans la terminale autorole.\\n\\nVeuillez r√©pondre avec un **titre** pour votre int√©gration du bot r√©action!`\n    msg.channel.send(embedTemplate)\n        .then((message) => {\n            msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                    max: 1,\n                    time: 60000,\n                    errors: ['time'],\n                })\n                .then(async function(collected) {\n                    embedSettings[0] = collected.first().content;\n                    msg.author.lastMessage.delete();\n                    embedTemplate[\"description\"] = `Votre titre est **${collected.first().content}**\\n\\nSi vous √™tes s√ªr de ce titre, veuillez r√©pondre avec une **description** pour votre embed.\\nDans le cas contraire, entrez \"**cancel**\"`;\n                    message.edit(embedTemplate);\n\n                    msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                            max: 1,\n                            time: 60000,\n                            errors: ['time'],\n                        })\n                        .then(async function(collected) {\n                            embedSettings[1] = collected.first().content;\n                            msg.author.lastMessage.delete();\n                            if (collected.first().content.toLowerCase() != \"cancel\") {\n                                embedTemplate[\"description\"] = `Votre titre est **${embedSettings[0]}** et votre description sera:\\n\\n${embedSettings[1]}\\n\\nSi vous √™tes satisfait avec ce choix, veuillez entrer \"**confirm**\".\\nDans le cas contraire, entrez \"**cancel**\".`;\n                                message.edit(embedTemplate);\n\n                                msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                                        max: 1,\n                                        time: 60000,\n                                        errors: ['time'],\n                                    })\n                                    .then(async function(collected) {\n                                        msg.author.lastMessage.delete();\n                                        if (collected.first().content.toLowerCase() == \"confirm\") {\n                                            reAsk(message, \" \");\n                                        } else {\n                                            errorMessage('Terminale interrompu, veuillez r√©executer la commande pour relancer le terminale!' , \"L'utilisateur n'a pas confirm√© sa description + titre\", message);\n                                        }\n                                    }).catch((error) => {\n                                        errorMessage('D√©sol√©, vous n avez pas fournis de r√©ponse dans le temps imparti!\\nVeuillez r√©executer la commande pour relancer le terminale!', error, message);\n                                    });\n                            } else {\n                                errorMessage(\"Terminale interrompu.\\nVeuillez r√©executer la commande pour relancer le terminale!\" , \"L'utilisateur a interrompu le terminale avec la commande cancel\", message);\n                            }\n                        }).catch((error) => {\n                            errorMessage('D√©sol√©, vous n avez pas fournis de r√©ponse dans le temps imparti!\\nVeuillez r√©executer la commande pour relancer le terminale!' , error, message);\n                        });\n\n                }).catch((error) => {\n                    errorMessage('Desole, vous n avez pas fournis de r√©ponse dans le temps imparti!\\nVeuillez r√©executer la commande pour relancer le terminale!', error, message);\n                });\n        })\n} else {\n    errorMessage(\"Vous n'avez pas la permission `MANAGE ROLES` pour √©xecuter cette commande!\" , \"L'utilisateur n'a aucune permission pour entrer cette commande!\");\n}\n\nfunction reAsk(message, extra) {\n    if (extra == null) {\n        extra = \"\";\n    }\n    if (reactionArray.length != roleLimit) {\n        var finalText = \"\";\n        reactionArray.forEach(subarray => {\n            finalText = finalText + `${subarray[0]} => ${subarray[2]}\\n`\n        })\n        embedTemplate[\"description\"] = `Veuillez entrer un **emoji-role** (Max ${roleLimit})\\n ${finalText}\\n\\nSi vous souhaitez associer une autre r√©action √† un r√¥le, veuillez ins√©rer un r√¥le avec un emoji.\\nEx. ExempleRole üòÉ\\nDans le cas contraire, entrez \"**done**\".\\nSi vous voulez interrompre le terminale, entrez \"cancel\"\\n\\n${extra}`\n        message.edit(embedTemplate);\n        msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n                max: 1,\n                time: 60000,\n                errors: ['time'],\n            })\n            .then(async function(collected) {\n                msg.author.lastMessage.delete();\n                if (collected.first().content.toLowerCase() == \"done\") {\n                    if (reactionArray.length > 0) {\n                        done(message);\n                    } else {\n                        errorCheck(message, `**Veuillez associer un emoji √† un role!\\nEssaie restant - ${errorCatch}**`, \"Le terminale a ete interrompu, vous avez associer un emoji √† 2 roles!\\nVeuillez reexecuter la commande pour relancer le terminale!\");\n                    }\n                } else if (collected.first().content.toLowerCase() == \"cancel\") {\n                    errorMessage(\"Terminale interrompu.\\nVeuillez r√©executer la commande pour relancer le terminale!\" , \"L'utilisateur a entr√©e la commande cancel, interrompant ainsi le terminale!\", message);\n                } else {\n                    var regString = collected.first().content;\n                    var execReg = /[^\\x00-\\x7F]/g.exec(regString) || /\\<:(.*?)\\>/g.exec(regString) || /\\<a:(.*?)\\>/g.exec(regString);\n                    var msgSplitArr = null;\n\n                    if (execReg != null) {\n                        msgSplitArr = [regString.substring(0, execReg[\"index\"]), regString.substring(execReg[\"index\"])];\n                    }\n\n                    if (msgSplitArr != null && msgSplitArr.length > 1 && msgSplitArr[0] != null && msgSplitArr[1] != null) {\n                        const tstValidRole = await msg.guild.roles.find(role => role.name === msgSplitArr[0].replace(/\\s+$/, ''));\n\n                        if (collected.first().mentions.roles.first() || tstValidRole != null) {\n                            var unicodeStored = msgSplitArr[1];\n                            if (collected.first().mentions.roles.first() != null) {\n                                roleMentioned = collected.first().mentions.roles.first();\n                            } else {\n                                roleMentioned = tstValidRole;\n                            }\n                            if (!roleArray.includes(roleMentioned.id) && !emojiArray.includes(unicodeStored)) {\n                                if (unicodeStored.includes(\"<:\") || unicodeStored.includes(\"<a:\")) {\n                                    var emoji;\n\n                                    unicodeStored = unicodeStored.replace(/\\D/g, '');\n                                    emoji = localEmoji.filter(emojiT => emojiT.id == unicodeStored);\n                                    if (emoji.length > 0) {\n                                        unicodeStored = emoji[0];\n                                        delete unicodeStored['guild']\n                                        reactionArray.push([unicodeStored, roleMentioned.id, roleMentioned.name]);\n                                        emojiArray.push(unicodeStored);\n                                        roleArray.push(roleMentioned.id);\n                                        reAsk(message);\n                                    } else {\n                                        errorCheck(message, `**Veuillez ins√©rer un emoji custom valide!\\n${localEmojiG}\\nEssaie restant - ${errorCatch}**`, `Terminale interrompu, vous avez associ√© un emoji non valide!\\n${localEmojiG}\\nVeuillez r√©executer la commande pour relancer le terminale!`)\n                                    }\n                                } else {\n                                    reactionArray.push([unicodeStored, roleMentioned.id, roleMentioned.name]);\n                                    emojiArray.push(unicodeStored);\n                                    roleArray.push(roleMentioned.id);\n                                    reAsk(message);\n                                }\n                            } else {\n                                errorCheck(message, `**Veuilez ne pas utiliser le role/emoji 2 fois!\\nEssaie restant - ${errorCatch}**`, \"Terminale interrompu.\\nVeuillez r√©executer la commande pour relancer le terminale!\\nVeuillez r√©executer la commande pour relancer le terminale!\");\n                            }\n                        } else {\n                            errorCheck(message, `**Veuillez entrer un role valide!\\nEssaie restant - ${errorCatch}**`, \"Terminale interrompu, vous n'avez pas associ√© un role valide!\\nVeuillez r√©executer la commande pour relancer le terminale!\");\n                        }\n                    } else {\n                        errorCheck(message, `**Veuillez entrer un role/emoji valide!\\nEssaie restant - ${errorCatch}**`, \"Terminale interrompu, vous n'avez pas associ√© un role/emoji valide!\\nVeuillez r√©executer la commande pour relancer le terminale!\");\n                    }\n                }\n            }).catch((error) => {\n                errorMessage('Desole, vous n avez pas fournis de r√©ponse dans le temps imparti!\\nVeuillez r√©executer la commande pour relancer le terminale!', error, message);\n            });\n    } else {\n        done(message);\n    }\n}\n\n\nfunction done(message) {\n    var finalText = \"\";\n    reactionArray.forEach(subarray => {\n        finalText = finalText + `${subarray[0]} => ${subarray[2]}\\n`\n    })\n    embedTemplate[\"description\"] = `Menu de confirmation final\\n\\nCi-dessous un r√©capitulatif des roles ainsi que des emojis associ√©s.\\n${finalText}\\n\\nSi tout est correct, veuillez **mentionner** un **canal** dans lequel le menu de role sera envoy√©.\\nSi ce n est pas correct, veuillez entrer \"**cancel**\" pour interrompre le terminale.`;\n    message.edit(embedTemplate);\n    msg.channel.awaitMessages(response => response.author.id == msg.author.id, {\n            max: 1,\n            time: 60000,\n            errors: ['time'],\n        })\n        .then((collected) => {\n            msg.author.lastMessage.delete();\n            if (collected.first().mentions.channels.first()) {\n                var menchannel = collected.first().mentions.channels.first()\n                message.delete();\n                menchannel.send({\n                        embed: {\n                            color: 16199315,\n                            title: embedSettings[0],\n                            description: `${embedSettings[1]}\\n\\n${finalText}`,\n                            timestamp: new Date()\n                        }\n                    })\n                    .then(embedmessage => {\n                        interval = setInterval(function() {\n                            emojiTimerInt(embedmessage, reactionArray);\n                        }, 500)\n                        rectarray[embedmessage.id] = reactionArray\n                        _this.storeValue(rectarray, 3, \"reactionRoleInf\", cache);\n                        fs.writeFile(\"./data/reactionRoleData.json\", JSON.stringify(rectarray), function(err) {\n                            if (err) {\n                                return console.log(err);\n                            }\n                        });\n                    })\n            } else {\n                errorMessage(\"Vous n avez pas mentionn√© un canal valide.\\nVeuillez r√©executer la commande pour relancer le terminale!\", \"L'utilisateur n a pas mentionn√© un canal valide, ce qui a interrompu le terminale.\", message);\n            }\n        }).catch((error) => {\n            errorMessage('D√©sol√©, vous n avez pas fournis de reponse √† temps!\\nVeuillez r√©executer la commande pour relancer le terminale!', error, message)\n        });\n}\n\nfunction emojiTimerInt(message, subarray) {\n    message.react(subarray[emojiTimerRe][0])\n    emojiTimerRe += 1;\n\n    if (emojiTimerRe == subarray.length) {\n        clearInterval(interval);\n    }\n}\n\nfunction errorMessage(error, errorCause, messageD = \"none\") {\n\n    if (debug) {\n        console.log(errorCause);\n    }\n\n    if (messageD != \"none\") {\n        messageD.delete();\n    }\n\n    let errorTemplate = new Discord.RichEmbed({\n        color: 0xFF0000,\n        author: {\n            name: client.user.username,\n            icon_url: client.user.avatarURL\n        },\n        title: \"Terminale de role\",\n        description: error,\n        timestamp: new Date(),\n    })\n\n    msg.channel.send(errorTemplate);\n}\n\nfunction errorCheck(mainMessage, erMsgCatch, erMsgFail) {\n    if (errorCatch > 0) {\n        errorCatch -= 1;\n        reAsk(mainMessage, erMsgCatch)\n    } else {\n        errorMessage(erMsgFail, \"L'utilisateur est √† cours d'essaie provoquant la fermeture du terminale.\", mainMessage);\n    }\n}","behavior":"1","interpretation":"1","storage":"0","varName":"","VTypeSelect":"0","CVTypeValue":"","name":"Run Script"}],"comType":"0"}]